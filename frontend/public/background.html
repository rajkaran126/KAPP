<!DOCTYPE html>
<html>

<head>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Gen-Z Color Palette - Vibrant!
    const colors = {
      neonTeal: '#00FFD1',
      electricBlue: '#00D4FF',
      hotPink: '#FF006E',
      purple: '#8B5CF6',
      gold: '#FFD700',
      cyan: '#22D3EE'
    };

    // Background gradient layers
    function drawBackground() {
      // Base gradient - deep space with vibrant colors
      const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      bgGradient.addColorStop(0, '#000000');
      bgGradient.addColorStop(0.3, '#0a0a1a');
      bgGradient.addColorStop(0.6, '#1a0a2e');
      bgGradient.addColorStop(0.85, '#16213e');
      bgGradient.addColorStop(1, '#0f3460');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Atmospheric glow in center - vibrant cyan/teal
      const centerGlow = ctx.createRadialGradient(
        canvas.width / 2, canvas.height * 0.4, 0,
        canvas.width / 2, canvas.height * 0.4, canvas.width * 0.6
      );
      centerGlow.addColorStop(0, 'rgba(0, 255, 209, 0.15)');
      centerGlow.addColorStop(0.4, 'rgba(0, 212, 255, 0.08)');
      centerGlow.addColorStop(0.7, 'rgba(139, 92, 246, 0.04)');
      centerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = centerGlow;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Particles - Stars with vibrant colors
    const stars = [];
    const starCount = 200;

    class Star {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 2 + 0.5;
        this.speedY = Math.random() * 0.3 + 0.1;

        // Random vibrant colors
        const colorChoices = [
          'rgba(255, 255, 255, ',
          'rgba(0, 255, 209, ',
          'rgba(0, 212, 255, ',
          'rgba(139, 92, 246, ',
          'rgba(255, 215, 0, '
        ];
        this.colorBase = colorChoices[Math.floor(Math.random() * colorChoices.length)];
        this.opacity = Math.random() * 0.5 + 0.3;
      }

      update() {
        this.y += this.speedY;
        if (this.y > canvas.height) {
          this.y = 0;
          this.x = Math.random() * canvas.width;
        }

        // Twinkle effect
        this.opacity += (Math.random() - 0.5) * 0.05;
        this.opacity = Math.max(0.2, Math.min(0.8, this.opacity));
      }

      draw() {
        ctx.fillStyle = this.colorBase + this.opacity + ')';
        ctx.shadowBlur = 4;
        ctx.shadowColor = this.colorBase + '0.5)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Initialize stars
    for (let i = 0; i < starCount; i++) {
      stars.push(new Star());
    }

    // Floating orbs - Gen-Z vibe
    const orbs = [];
    class Orb {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 60 + 30;
        this.speedX = (Math.random() - 0.5) * 0.5;
        this.speedY = (Math.random() - 0.5) * 0.5;
        this.hue = Math.random() * 60 + 160; // Cyan to purple range
        this.opacity = Math.random() * 0.15 + 0.05;
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;

        if (this.x < -this.size) this.x = canvas.width + this.size;
        if (this.x > canvas.width + this.size) this.x = -this.size;
        if (this.y < -this.size) this.y = canvas.height + this.size;
        if (this.y > canvas.height + this.size) this.y = -this.size;
      }

      draw() {
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.size
        );
        gradient.addColorStop(0, `hsla(${this.hue}, 100%, 60%, ${this.opacity})`);
        gradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 50%, ${this.opacity * 0.5})`);
        gradient.addColorStop(1, `hsla(${this.hue}, 100%, 40%, 0)`);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Create orbs
    for (let i = 0; i < 8; i++) {
      orbs.push(new Orb());
    }

    // Neon grid lines - Cyberpunk vibe
    const gridLines = [];
    class GridLine {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height + 10;
        this.length = Math.random() * 150 + 100;
        this.speed = Math.random() * 2 + 1;
        this.opacity = Math.random() * 0.3 + 0.2;
        this.color = Math.random() > 0.5 ? colors.neonTeal : colors.electricBlue;
      }

      update() {
        this.y -= this.speed;
        if (this.y + this.length < 0) {
          this.reset();
        }
      }

      draw() {
        const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y - this.length);
        gradient.addColorStop(0, this.color + '00');
        gradient.addColorStop(0.5, this.color + Math.floor(this.opacity * 255).toString(16).padStart(2, '0'));
        gradient.addColorStop(1, this.color + '00');

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 1.5;
        ctx.shadowBlur = 8;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y - this.length);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    // Create grid lines
    for (let i = 0; i < 15; i++) {
      gridLines.push(new GridLine());
    }

    // Energy rings - pulsing effect
    let ringPhase = 0;
    function drawEnergyRings() {
      ringPhase += 0.02;

      for (let i = 0; i < 3; i++) {
        const radius = 100 + i * 80 + Math.sin(ringPhase + i) * 20;
        const opacity = (Math.sin(ringPhase + i * 0.5) + 1) * 0.1;

        ctx.strokeStyle = `rgba(0, 255, 209, ${opacity})`;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 15;
        ctx.shadowColor = colors.neonTeal;
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height * 0.4, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    // Animation loop
    function animate() {
      drawBackground();

      // Update and draw orbs
      orbs.forEach(orb => {
        orb.update();
        orb.draw();
      });

      // Update and draw grid lines
      gridLines.forEach(line => {
        line.update();
        line.draw();
      });

      // Draw energy rings
      drawEnergyRings();

      // Update and draw stars
      stars.forEach(star => {
        star.update();
        star.draw();
      });

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>

</html>